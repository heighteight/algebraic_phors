% !TEX root = main.tex

In this section we provide an overview of our approach to probabilistic termination via algebraic generating functions.

\paragraph*{The Generating Function of a PHORS}



Consider a program $\gphors$ defined by the following equations:
\begin{equation}\label{eq:introphors1}
\begin{aligned}
Fx&= x\oplus_{\frac{1}{2}} Fx\\
S& =F \  e
\end{aligned}
\end{equation}
where $F:o\to o$. 
This is a very simple example of a PHORS: the upper case letters $F,S$ are called \emph{non-terminal} symbols, the execution of the program starts from the \emph{source} non-terminal $S:o$ by applying instances of the equations, read from left to right, as well as probabilistic choices, terminating when the unit constant $e:o$ is, eventually, produced. 
If we ignore probabilities, we can consider the \emph{branch language} $\C L(\gphors)$ computed by the PHORS $\gphors$ as follows:
 replace the choice operation $\oplus_{\frac{1}{2}}$ with a binary terminal symbol $c:o\to o\to o$, and consider the following HORS (i.e.~non-probabilistic recursion scheme) $\gphors'$,  where $G:(o\to o\to o)\to \tau$:
\begin{equation}\label{eq:introphors2}
\begin{aligned}
Gzx&=  zx( Gzx)\\
S& =F \ c \ e?
\end{aligned}
\end{equation} 
The execution of $\gphors'$ produces an infinite tree whose finite branches form the language $\C L(\gphors)=\{c^{n}e\mid n\in \N\}$.


%
%Consider a program $\gphors$ defined by the following equations:
%\begin{equation}\label{eq:introphors1}
%\begin{aligned}
%Ffx&= x\oplus_{\frac{1}{2}} Ff(fx)\\
%S& =F \ I \ e
%\end{aligned}
%\end{equation}
%where $F:\tau\to\tau$, $S:o$, with 
%$o$ a ground type, 
%$\tau=o\multimap o$ the type of \emph{linear} functions from $o$ to itself, that is, of functions that use their input exactly once, $I:\tau$ indicating the identity function and $e:o$ a constant of ground type.
%This is an example of PHORS: the upper case letters $F,S$ are called \emph{non-terminal} symbols, the execution of the program starts from the \emph{source} non-terminal $S:o$ by applying instances of the equations, read from left to right, as well as probabilistic choices, terminating when the unit constant $e:o$ is, eventually, produced. 
%If we replace the choice symbol $x\oplus_{\frac{1}{2}}y$ by a binary constant $c:o\multimap o\multimap o$, and we execute the source $S$, we see that it produces an infinite tree whose finite branches form the \emph{branch language} $\C L(\gphors)=\{c^{n}e\mid n\in \N\}$ of the PHORS.
%

Our goal is to extract a generating function from programs like \eqref{eq:introphors1}, i.e.~a formal power series $a_\gphors(z)=\sum_{i=0}^\infty a_iz^i$ capturing the probabilistic termination of $\gphors$. Recall that a power series induces an \emph{analytic function} defined over some open subset $U\subset \mathbb C$ of the field of complex numbers, and, when this set is not empty, can thus be studied with methods coming from both algebra and complex analysis. For instance, the formal power series $a(x)=\sum_{n=0}^\infty \frac{1}{2^n} x^n$ is equal to the analytic function $a(x)=\frac{1}{1-\frac{x}{2}}$ over the open set of complex numbers of absolute value strictly less than $ 2$.
% (riformulare come 'the power series is an expansion of the analytic function??'\warn).

As anticipated, our fundamental ingredient to extract generating functions from PHORS is the weighted relational model of linear logic. This semantics is often styled \emph{quantitative}, as it provides a \emph{precise count} of the number of times that a program may use each of its inputs during any of its reductions.
If we consider the HORS $\gphors'$, we see that, for any $i\in \N$, the term $Gzx$ has a unique way of terminating using $z$ exactly $i$ times; formally, each such reduction yields, in the semantics, a monomial of the form $z^{i}x$. By considering all possible reductions, the corresponding monomials yield then the power series below, interpreting the non-terminal $G$:
\[
a_{G}(z,x)=\sum_{i>0}^{\infty}z^i x
\]
We can get back to the original PHORS $\gphors$ by interpreting the ``choice'' constant $c:o\multimap o\multimap o$ as the linear map $c(z)(x,y)=z(\frac{1}{2}x+\frac{1}{2}y)$; the parameter $z$ here intuitively counts the number of times that a choice is made; indeed, all this yields the generating function
%
%We can back to the original PHORS $\gphors$, interpret
\[
a_{F}(z,x)=\sum_{i>0}^{\infty}\frac{1}{2^i}z^i x=\frac{x}{1-\frac{z}{2}}-x
\]
which says that the probability that $Fx$ terminates using $x$ once and making $i>0$ choices (i.e.~using $z$ $i$ times) is $\frac{1}{2^i}$. 
As $e$ trivially terminates with probability 1, we can then associate the source symbol $S$ with the generating function
$a_{S}(z):=a_{F}(z,1)=\sum_{i>0}^{\infty}\frac{1}{2^i}z^i=\frac{1}{1-z/2}-1$,
which describes the reductions with $i$ choices, and deduce that $\gphors$ terminates with probability $a_{S}(1)=1$, i.e.~almost surely. 

%
%has only one (trivial) way of terminating, we obtain the following generating functions 
%
%
% constants, i.e.~they have just one (trivial) reduction, we can then associate 
%
% For example, a probabilistic program $F:\tau\to \tau$ yields, in the relational semantics, a generating function of the form
%$$
% \model{F}(f,x)=\sum_{n=0}^{\infty}F_n f^n x,
%$$ 
%where $F_n$ designates the probability that $Ffx$ terminates using $f$ exactly $n$ times.
%For example, taking $F$ as given by \eqref{eq:introphors1}, we obtain the power series
%% $t$ may be defined as the solution of the fixpoint equation
%%\[
%%Ffx= x\oplus_{\frac{1}{2}} Ff(fx)
%%\]
%%Then $F$ yields the power series 
%$$ \model{F}(f,x)=\sum_{n=0}^\infty \frac{1}{2^{n+1}}f^n x=\frac{x}{2-f},$$
%observing that $Ffx$ generates the infinite probabilistic tree 
%$x\oplus_{\frac{1}{2}} (fx\oplus_{\frac{1}{2}} (f^2x\oplus_{\frac{1}{2}} (f^3x\oplus_{\frac{1}{2}} \dots$, and thus its probability of terminating using $f$ exactly $n$ times is $\frac{1}{2^{n+1}}$.
%Then, the probability of termination of $S$ can be computed, since $S=FIe$, as
%$\model{F}(1,1)=\frac{1}{2-1}=1$ (since both the identity and the constant $e$ terminate with probability $1$).


Using the ideas just sketched, as we show in Section 4, any PHORS $\gphors$ can be associated with a generating function 
$
a_{\gphors}(z):=a_{S}(z)=\sum_{n=0}^\infty \gphors_n z^n
$
such that $\gphors_n$ designates the probability that $\gphors$ terminates after \emph{exactly} $n$ reduction steps. Observe that the probability of termination of $\gphors$ is given by $a_{\gphors}(1)$. Moreover, $a'_{\gphors}(1)$, where
$a'_{\gphors}(z)=\sum_{n=0}^{\infty}n\gphors_n z^{n+1}$ indicates 
the \emph{derivative} of $a_{\gphors}(z)$, precisely captures the expected number of reduction steps to termination. 
%
%We think that the main value of this work resides in enabling the application of well-established methods from algebraic and analytic combinatorics to higher-order languages.
%As we'll see, this will allow us to reestablish, in a relatively elementary way, some already known results about the decidability of certain classes of PHORS (proved in the literature with syntactic methods like automata theory or intersection types), and actually to \emph{extend} such decidability results to larger classes of PHORS.

It is worth observing at this point that, in our setting, the generating function $a_\gphors(z)$, while characterizing the termination problem for the PHORS $\gphors$, is \emph{not} an invariant of the corresponding branch language: for instance, two PHORS respectively inducing the non context-free language $\C L_1=\{0^n1^n0^n\mid n\in \N\}$ and the context-free language 
$\C L_2=\{0^n1^{2n}\mid n\in \N\}$ would \emph{both} induce a rational generating function of the form $a(z)=\sum_{n=0}^{\infty}\frac{1}{2^{3n}}z^{3n}=\frac{1}{1-\left({z}/{2}\right)^3}$, as the latter only counts the number of reduction steps to termination. 




%
%Observe that we are silently assuming, for simplicity, that order 1 programs $P:o\to o$ are always \emph{linear}, that is, they may use their input precisely once. This implies that any such program is interpreted by a unique coefficient (the probability of $P$ terminating using its input once), and that the variable $x$ above may indeed only occur with exponent 1. While this is a simplification, it is not a very strong one, since, as we will see in Section ??,  order-1
%PHORS are always \emph{affine}, that is, they may use their input variables \emph{at most} once.
%
%
%
%
%
%\begin{align*}
%Hfx&= H(B\circ f)x \oplus_{p_1} (f\circ f)(Bx)\\ 
%Bx&= x\oplus_{p_2} \Omega\\
%S&= HB e
%\end{align*}
%
%
%Language associated:
%$$
%\{ 
%a^{n}b^{2n}\mid n\in \mathbb{N}, n\geq 1
%\}
%$$
%
%\begin{align*}
%Hfgx&= H(A\circ f)(B\circ g)x \oplus_{p_1} (f\circ g\circ f)x\\ 
%Ax&= x\oplus_{p_2} \Omega\\
%Bx&= x\oplus_{p_3} \Omega\\
%S&= HAB e
%\end{align*}
%
%Language associated:
%$
%\{ 
%c^{n+1}a^{n}b^{n}a^n\mid n\in \mathbb{N}\}
%$

\paragraph*{Algebraic Generating Functions via Bounded Exponentials}

Consider now a slightly more complex PHORS $\gphors$, defined by:
\begin{equation}\label{eq:phors1}
\begin{aligned}
Hfx&=( H(A\circ f)x \oplus_{a}
H(B\circ f)x )\oplus_{a}f(fx)\\
Ax&= x\oplus_{b} \Omega\\
Bx&=x\oplus_{c} \Omega\\
S&=HIe,
\end{aligned}
\end{equation}
where $H:\tau\to \tau$, $A,B:\tau$ and $S:o$, $\Omega$ stands for a diverging term, 
and $a,b,c,d$ stand for rational biases for the probabilistic choice operators. Observe that $H$ is not linear, as it may use the variable $f$ twice.
%
%This is indeed an example of PHORS: the upper case letters are called \emph{non-terminal} symbols, the execution of the program starts from the order 0 non-terminal $S$ by applying instances of the equations, read from left to right, as well as probabilistic choices, until the unit constant $e$ is, eventually, produced. 
%Notice that $I$ and $\Omega$ stand, respectively, for the identity and diverging terms, and that $a,b,c,d$ stand for rational biases for the probabilistic choice operators.
Using distinct constants $a,b,c:o\multimap o\multimap o$ for each choice symbol we can see that the branch language of $\gphors$, namely
%
%We can canonically associate an infinite tree with the program above by considering binary function symbols $a,b,c$ with each choice operator. The word language (defined as in \cite{}) consisting of all the finite branches of this tree is then 
$$
\mathcal L(\gphors)=\{ a^{2|w|+2}ww\mid w\in \{b,c\}^*\}.
$$
is not context-free, as it contains an arbitrary word repeated twice.


%In the relational interpretation, a non-terminal symbol $N$ yields a sequence of coefficients $N_n$ (and a corresponding generating function  $\model{N}(y,x)=\sum_nN_ny^n x$), and each order-1 non-terminal $N$ yields a unique real coefficient. 
In the weighted relational semantics, the non-terminal $H:\tau\to\tau$ yields, as before, a generating function $a_{H}(z,f,x)=\sum_{i}^{\infty}H_{i}(z) f^{i} x$, where
$H_{i}(z)=\sum_j H_{ij}z^j$ is the generating function counting the probability that $Hfx$ terminates using $f$ exactly $i$ times, $x$ once, and making $j$ probabilistic choices.
%$A,B:\tau$ yield two real values, and $S:o$ yields a real value capturing the probability of termination of the PHORS.
%Using $\model{H}(f,x)=\sum_nH_nf^n x$, 
By translating equations \eqref{eq:phors1} into equations between the corresponding power series, we are led to the following equations for the coefficients $H_{ij}$: 
\begin{equation}\label{eq:poly}
\begin{aligned}
H_{2}(z)&=
\alpha H_{2}(z)z^2  +\beta z, \qquad\qquad  H_{ij}=0 \quad (i\neq 2),
%\model{A}x&=bx+(1-b)0\\
%\model Bx&=cx+(1-c)0\\
%\model S&=H_2\cdot 1\cdot 1,
\end{aligned}
\end{equation}
where $\alpha=(a^2b^2+a(1-a)c^2)$ and $\beta=1-a$.
The generating function 
$a_{`Hfx'}(z,f,x)=H_2(z)f^2x$ can then be computed by finding a solution of the \emph{polynomial equation}
\[
p(z,H_2(z))=0,
\]
where $p(z,w)= (\alpha z^2-1)w+\beta z$, yielding 
$a_{H}(z,f,x)= \frac{\beta z}{1-\alpha z^2}f^2x$. 
This yields the termination probability $a_{\gphors}(1)=
a_{H}(1,1,1)=
\frac{\beta }{1-\alpha }$.

%
%
%The probability of termination of $\gphors$, given by $\model S=\model{H}(1,1)=H_2$, can then be computed as a root of the polynomial
% $p(z)=(\alpha-1) z+ \beta $ (since $p(H_2)=0$), yielding $\model{S}=\frac{\beta }{1-\alpha}$.
%More generally, the generating function $\model{H}(f,x)$ is solution of the polynomial equation
%$ p(x,f,\model{H}(f,x))=0$, and is thus algebraic.


%, and in this case we can easily compute a closed form $\model{H}(f,x)=\frac{a-1}{a^2b^2+a(1-a)c^2-1}$, and thus
%$\model{S}=\model{H}(1,1)=$.
 
%
%Now, observe that from the equations above it follows 
%$$
%\model{H}(y,x)= \alpha\cdot \model{H}(y,x)+\beta y^2x
%$$
%that is, the power series $\model{H}(y,x)$
%
%
%On the one hand, we immediately get $A\cdot x= bx$ and $ B\cdot x=cx$, that is, $A=b, B=c$; for the $H_n$ we can solve using $\model{H}(y,x)=\sum_n H_n y^n x$, which yields
%\begin{align*}
%H_2y^2 x&= 
%\alpha
%H_2y^2x
%+ \beta y^2x,\\
%H_ny^n x&= 0 \qquad (n\neq 2),
%\end{align*}
%In other words, $H_n=0$ for all $n\neq 2$, while $z=H_2$ 
%%is a root of the polynomial $\mathscr p\in \BB R[x,y][z]$
%%$$
%%\mathscr p(x,y)(z)=\delta xy^2 \cdot z+ (1-a)xy^2,
%%$$
%%which 
%can be easily computed $H_2=\frac{a-1}{a^2b^2+a(1-a)c^2-1}$. 
%Notice that this implies that a reduction of $H$, \emph{independently of the number of its unfoldings}, will always end up using its functional input precisely twice.


%This example illustrates one fact that is general and one that only works in a \emph{restricted} class of situations. The general fact is that, for any PHORS $\gphors, the generating function $a_{\gphors}(z)$ is defined via a family of real coefficients which are mutually defined via a system of equations. 

Unfortunately, termination probabilities cannot always be computed algebraically, as above.
For instance, it is well-known that the generating functions of order-2 PHORS (which correspond to the so called \emph{indexed grammars}, cite) may fail to be algebraic \cite{DBLP:journals/ita/AdamsFM13}. 
In our semantics, the generating function $a_{\gphors}(z)$ of a PHORS $\gphors$ will be determined by a (countably) infinite family of equations, which we might not be able to solve algebraically. 
%Probability of termination for PHORS is still undecidable, anyway.
 
The main theme of this work is then to find conditions under which the generating function $a_{\gphors}(z)$ may be found by solving some \emph{finite system of polynomial equations}, 
and is, as a consequence, algebraic.
Indeed, by relying on the decidability of the \emph{first order theory of the reals} $\Etor$ (see for example \cite{Marker2002-jm} for an account of this classic result by Tarski), from the algebraicity of $a_{\gphors}(z)$ we will deduce the existence of effective methods to answer both the AST and PAST problem for the corresponding PHORS $\gphors$.


\paragraph*{Algebraic PHORS via Bounded Exponentials}

Such conditions come, once more, from the toolbox of linear logic: 
as the relational semantics counts input uses, 
bounding the number of equations interpreting the program amounts at bounding the number of uses that the program may do of each of its inputs.
A first natural idea is thus to restrict ourselves to linear, or even affine, programs, as in \cite{DBLP:conf/lics/LiMO22}. Yet, the PHORS in \eqref{eq:phors1} shows that one can well admit {bounded} forms of non-linearity. 
A standard and well-studied way to impose such bounds is via \emph{bounded  exponentials} (cite people) $!_nA$, where a program $t:\ !_nA\multimap B$ may use its input \emph{at most} $n$ times. 
%Notice that, as we will see, this restriction continues to hold in presence of fixpoints: if $A$ is a finitely graded higher-order type and $M: A\to A$ is a program which may use its input $A$ \emph{unrestrictedly}, then its fixpoint $\mathrm{Fix}M:A$ is still ``finitary''.
%: its interpretation still has a number of unknowns, which can be traced as the points of some algebraic variety, as we'll see.
In our example, the non-terminal $H:\tau \to\tau$ could be given the bounded type $!_2\tau\multimap \tau$, as $H$ uses its input $f$ twice (indeed, all generating functions $H_i(z)$ are equal to zero, for $i\neq 2$).
%This leads us to introduce the class $\Gfin$ of bounded PHORS. 


But it is possible to go even beyond that, still preserving decidability.
Similarly to the way in which we handle the formal variable $z$ counting probabilistic choices, 
we show that it is possible to use variables in a PHORS in an \emph{unbounded} way, provided this variable behaves as a \emph{formal parameter} of the PHORS.
This will allow us to use also infinitely graded types $!_\infty\sigma\multimap \tau$, although in a restricted way. 
This idea leverages the intrinsically parametric nature of the weighted relational semantics, which allows one to pass smoothly from power series $s(x,w)$ in $x,w$, with values over some continuous semiring $\Rsemiring$, to ``parametric'' power series $s(w)(x)$ in $x$ with values themselves of the continuous semiring $\fps{\Rsemiring}{w}$ of power series in $x$.
% an algebraic PHORS $\gphors_1(w)$, depending on some unbounded parameter $w$, with another algebraic PHORS $\gphors_2$, yielding a new PHORS $\gphors_1(\gphors_2)$, in which $\gphors_2$ is used unrestrictedly. 


%\paragraph*{, }
%
%In this work we show that the combinatorial approach enabled by the weighted relational semantics allows us to prove the decidability of AST and PAST for 
% two classes of PHORS that extend the affine PHORS of (Ong et al.) by allowing bounded and unbounded duplications.
% 
%At the same time, there is a sense in which our approach essentially recovers, via different methods, \emph{the same} class of PHORS as (Ong et al.), hence suggesting its robustness wrt decidability: we will show that, for each PHORS from our two classes, it is possible to construct an affine PHORS inducing the same generating function and branch language.
%Still, such affine PHORS will be in general considerably larger (indeed, \emph{more} than exponentially larger) than the original, non-linear, ones, and thus possibly very hard to even write down in practice.


%A natural question is whether such classes also extend the corresponding class of branch languages.
%
%Interestingly, we prove that the $\Gfin$ and the $\Ginf$ on one side, and the affine PHORS on the other, all capture \emph{the same} class of languages. 
%In other words, while our combinatorial approach, different from the one of (Ong et al.) relying on automata theory, characterizes a different class of PHORS, we end up characterizing the same class of trees. In our opinion, this fact suggests the robustness of this decidable class of trees.
%
%This equivalence will be proved by applying a well-known recipe from linear logic (cite Girard, Mazza,...), which consists in replacing a (bounded) exponential $!_nA$ with an $n$-fold tensor $A\otimes\dots\otimes A$. 



%
%
% In our previous example, while we imposed a bound via the type $!_2\tau\multimap\tau$ to the number of uses that $H$ may do of its functional input, we imposed no \emph{a priori} bound on the number of probabilistic choices, i.e.~on the variable $z$.  In other words, if we look at probabilistic choice as some variable $z: o\multimap o\multimap o$, we can let our bounded programs use this variable \emph{as many times} as needed, without compromising algebraicity.
%
%
%
%Can we internalize, then, such unbounded uses in our bounded calculus?
%A positive answer is proposed via the introduction of 
%\emph{parametric} PHORS, that is, PHORS that may use a few inputs, called parameters, in an unbounded way. Technically, parameters are typed with an \emph{infinite} grade, i.e.~via types of the form $!_\infty A\multimap B$. 
%
%
%
%Obviously, in order to preserve algebraicity, the use of parameters has to be restricted in some way; 




%Formally, this can be captured by looking at this PHORS as an algebraic formal power series 
%with coefficients taken \emph{themselves} from a semiring of formal power series. In the relational semantics, this corresponds to lifting the underlying continuous semiring of weights from the (extended) positive reals $\BB R_{\geq 0}^\infty$ to the semiring of formal power series
% 
%
%
%distinct PHORS through som
%
%
%There exists way of using some input that can be unbounded, like z
%In all our examples.
%Moreover, algebraic power series can (modulo some caveats) be composed, 
%Which means that we can replace z with some other power series. 
%
%Can we internalize such unbounded uses in our bounded calculus?
%
%Parametric PHORS: a parameter can be used unboundedly in the PHORS, 
%Still preserving algebraicity.
%Moreover, PHORS can be freely composed through parameters.




%Notice that, while algebraic PHORS $\gphors$ may well be non-linear, the corresponding language $\C L(\gphors)$ could still be obtained via an affine PHORS: this fact can be easily obtained by applying a well-known recipe from linear logic, called \emph{linear approximation} (cite Girard, Mazza??), and consisting in translating 


%
%At the same time, observe that, while our example is non-linear, it can well be \emph{linearized}: we can design some affine PHORS that generates the same infinite tree, for example:
%\begin{align*}\label{eq:phors2}
%Ly_1y_2x&=( L(A\circ y_1)(A\circ y_2)x \oplus_{a}
%L(B\circ y_1)(B\circ y_2)x )\oplus_{a}y_1(y_2x)\\
%Ax&= x\oplus_{b} \Omega\\
%Bx&=x\oplus_{c} \Omega\\
%S&=HIIe
%\end{align*}
%Notice that the unique functional variable $y$, that was used twice, is now replaced by \emph{two} functional variables $y_1,y_2$, used once.
%Linearization is a well-known procedure in linear logic which, intuitively, corresponds to unfolding a (finite) exponential $!_nA$ as an $n$-fold tensor $A\otimes\dots \otimes A$. 
%As a consequence, the word languages that are obtained via PHORS typed via graded exponential coincide with those obtained via the affine PHORS of \cite{}. 
%However, notice that the linearized PHORS may well have a number of variables that is exponential with respect to those of the original, non-linear one. 


%\paragraph*{Deciding AST and PAST for Finitary PHORS}




%
% \emph{almost sure termination} problem (AST) and \emph{positive almost sure termination} (PAST) can be decided for a PHORS typable via graded types.
%Let us recall that AST and PAST are, respectively, the problems to know whether a program terminates with probability 1, and whether its expected number of steps before termination is finite. 
%
%Given a PHORS typable via graded types, we have seen that, for each non-terminal symbol $N$, the associated power series $\model{N}$ contains finitely many non-zero terms $N_ky^k$. As all such (finitely many) coefficients are given in terms of the other ones via polynomial equations, the set of their possible values forms an algebraic variety.
%As a consequence, the interpretation of the source non-terminal $S:o$, which is obtained by combining other non-terminals as well as a unique constant $e:o$, can be expressed as a polynomial combination of the coefficients. 
%At this point, it is not difficult to design a formula in the decidable \emph{first order theory of the reals} \cite{} that expresses that such a polynomial combination of algebraic reals is equal to 1, and thus to decide AST.
%
%We can also obtain a first-order formula expressing PAST as follows.
%In the relational semantics a choice $M\oplus_a N$ with bias $a$ is interpreted as a convex sum $a\model M+(1-a)\model N$; in order to count the number of reduction steps we can multiply each such convex sum by a fresh parameter $w$, yielding $w(a\model M+(1-a)\model N)$. 
%Logically, this corresponds to adding a fresh linear variable $w:o\multimap o$ and replacing each choice $M\oplus_a N$ by $w(M\oplus_a N)$. 
%Notice then that, with this new variable in the game, the type of the source non-terminal $S$
%is now $(o\multimap o)\multimap o$, that is, $S$ 
% is now interpreted as a formal power series 
%$\model{S}(w)=\sum_{n=0}^\infty S_nw^n$, where $S_n$ is the probability of termination using the fresh parameter $w$ exactly $n$ times, that is, making exactly $n$ probabilistic choices. We will show in Section \ref{} that the power series $\model{S}(w)$ remains algebraic even after this \emph{parameterization} via $w$.
%
%As a paradigmatic example, consider the order-1 PHORS
%\begin{align*}
%Fx&= F(Fx)\oplus_{\frac{1}{2}} x & S&=Fe,
%\end{align*}
%corresponding to a simple random walk. Parameterizing $ F(Fx)\oplus_{\frac{1}{2}} x$ as $w( F(Fx)\oplus_{\frac{1}{2}} x)$ yields the algebraic power series $C(w)$ given by 
%$$
%C(w)= \frac{1}{2}\cdot {(wC^2(w)+w)},
%$$
%whose solution gives precisely the generating function of the {Catalan numbers}
%$C(w)=\sum_{n=0}^\infty C_nw^n = \frac{1-\sqrt{1-4w}}{2w}$ (it is indeed well-known that $C_n$ counts the number of $n$-step paths for the simple random walk)
%
%
%Now, observe that the expected number of steps (i.e.~of probabilistic choices) is precisely given by $\model{S}'(1)$, where $\model{S}'$ is the \emph{derivative} of $\model{S}$:
%$$
%\model{S}'(w)=\sum_{n=1}^\infty n\cdot S_{n}w^{n-1}.
%$$
%The derivative $a'(x)$ of an algebraic power series $a(x)$ is still an algebraic power series,
%and there is a well-known method to express $a'(x)$ as a polynomial in $a(x)$ with rational function coefficients \cite{}. All this allows us to express PAST (i.e.~$\model{S}'(1)<\infty$) via some first-order formula over the real numbers, and thus to decide it.
%
%
%
%



%
%
%\paragraph*{Composing PHORS via (Unbounded) Parameters}
%
%As we saw, a PHORS typable via graded types may use its functional inputs only a bounded number of times, independently of the number of its unfoldings. 
%On the other hand, in Section ?? we explore a \emph{parameterization method} that can be used to show the algebraicity also of PHORS that may use their functional inputs an \emph{arbitrary} number of times.
%
%Indeed, an instance of this method underlies our previous discussion of PAST, which relied on showing that the generating function $\model S(w)=\sum_{n=0}^\infty S_nw^n$ for the number of steps to termination of an algebraic PHORS is itself an algebraic power series, in which the variable $w$ may appear arbitrarily many times.
%
%The same idea can then be used to show the algebraicity also for PHORS which are not finitary. For instance, the following order-2 PHORS
%\begin{align*}
%Lyx&=Ly(Lyx)\oplus_a y(yx),\\
%Bx&= x\oplus\Omega,\\
%S&= LBe,
%\end{align*}
%can be seen as a functional and non-linear variant of the simple random walk, in which the function variable $y$ may be used an arbitrary (even) number of times. 
%
%What makes this example, as well as the previous ones, work, is the remark that the non-terminal $L$ uses the functional variable $y$ as a parameter, that is, we are never asked to compute values of $L$ over, say, $y^2$ or $2y+1$. 
%Formally, this can be captured by looking at this PHORS as an algebraic formal power series 
%with coefficients taken \emph{themselves} from a semiring of formal power series. In the relational semantics, this corresponds to lifting the underlying continuous semiring of weights from the (extended) positive reals $\BB R_{\geq 0}^\infty$ to the semiring of formal power series
%$\fps{\BB R_{\geq 0}^\infty}{y}$ in the variable $y$, as explained for instance in \cite{}.
%At the same time, we show that all such cases can be captured by extending our graded type system with a new rule that allows to introduce \emph{infinite} grades $!_\infty A$ in a controlled way. 
%


%
%\begin{align*}
%Hfx&= (p_1H(p_3fx)+p_2H(p_4fx) + (1-p_1-p_2)f^2x\\
%&= (p_1p_3+p_1p_4)Hfx+(1-p_1-p_2)f^2x
%\end{align*}
%
%So $y=H(f,x)$ is solution of the polynomial equation $\mathscr p(f,x,y)=0$, where
%$$
%\mathscr p(f,x,y)= (p_1p_3+p_1p_4-1)y+(1-p_1-p_2)f^2x.
%$$
%
%The solution sequence $(H_n)_{n\in\mathbb N}$ is the following: 
%\begin{align*}
%H_n&=0 \quad (n\neq 2)
%\\
%H_2&=\sum_{k=0}^\infty\sum_{k=m+n}(p_1p_3)^m(p_2p_4)^n\\
%&= \sum_{m,n}(p_1p_3)^m(p_2p_4)^n\\
% &=\sum_{m=0}^\infty(p_1p_3)^m\cdot \sum_{n=0}^\infty(p_2p_4)^n\\
% &=\frac{1}{1-p_1p_3}\cdot \frac{1}{1-p_2p_4}
%\end{align*}
%which yields the probability of termination $\sum_nH_n=\frac{1}{1-p_1p_3}\cdot \frac{1}{1-p_2p_4}$.
%\begin{itemize}
%
%\item fundamental idea: when studying the relational interpretation of a probabilistic program, we can look at it as a formal power series, whose coefficients can be seen as \emph{countably many} unknowns. These are infinite since one has to consider trajectories that may use inputs an arbitrary number of times (as in the example above)
%
%%\item fixpoints corresponds then to imposing a system of \emph{polynomial equations} over such unknowns; yet, solving a system of infinitely many polynomial equations is far beyond what can be hoped!
%
%\item yet, what it we impose a \emph{bound} on the number of uses that the program can do of each of its inputs?
%This is a well-known approach that uses \emph{(affine) graded types} $!_nA\multimap B$, meaning ``produce $B$ using an input $A$ at most $n$ times'' 
%
%\item under such constraints, the number of unknowns to find becomes \emph{finite} (although possibly very large). In a similar way, when computing the semantics of $\mathrm{fix}M:A$, where $A$ is finitely graded but $M:A\To A$ may use its input $A$ unboundedly, we show that we obtain a system of \emph{finitely} many polynomial equations, whose solution set forms then an \emph{algebraic variety}.
%
%\item Using standard algebraic reasoning, the interpretation of this fixpoint is thus shown to be a power series $F$ that is solution of a \emph{unique} polynomial equation $p(x,F(x))=0$, yielding the decidability of AST. 
%
%
%\end{itemize}
