In this section we will introduce Higher Order Recursion Schemes (HORS) and their probabilistic counterpart, Probabilistic  Higher Order Recursion Schemes. HORS, widely used in higher order model checking, can be seen as grammars that generate infinite ranked trees (or equivalentely, infinite typed lambda terms).
In the theory of HORS, the simple types are generated by the grammar $T= \1 \mid T \to T$. We can also define the order of a type $ord(\1) =0$ and $ord(T \to S)= \max(ord(T)+1, ord(S))$.
An HORS $\gphors$ can then be defined as a 4-uple $\phors$ where $\mathcal{N}$ is a set of typed non-terminals, $\mathcal{T}$ is a set of typed terminals, $S$ is a distinguished non-terminal called the starting symbol of $\gphors$ and $\mathcal{R}$ is a set of rewriting rules, at least one for each non terminal, of the form:
$L x_1 \dots x_n = t$, where $FV(t) \subseteq \{x_1, \dots x_n\} \cup \mathcal{T}$. These rules are to be understood as recursive definition of the non-terminals that can be progressively unfolded: to $\gphors$ we will associate the rewriting system induced by the rules $L t_1 \dots t_n \to t[x_1/t_1, \dots x_n/t_n]$. The rewriting - beginning from $S$ - will generate at each step finite (simply typed) terms containing the terminals $\mathcal{T}$; the "limit" of this set of terms will be the $\textit{value tree}$ defined by the $\mathcal{G}$ (for formal definitions, see Carayol or the overview by Ong). The nodes of this tree will be labelled by non terminals and its branching factor at each node will be equal to the arity of the non terminal labelling that node.  If there is \textit{exactly} one equation for each non-terminal, the HORS is said deterministic; otherwise, it is non deterministic.Given an HORS, its order is defined as the maximal order of its non terminals.\\
Ranked trees can be equivalentely defined as set of words over an alphabet, called the branch language of the tree (cite Courcelle, 1981 and survey by Ong). HORS can also deal with this different approach. To see this, recall that a word can be seen as a tree with branching factor at most one; hence an HORS only involving terminals of arity 1 is called a word-generating HORS. Given an HORS, we can always build another HORS of the same order that generate the branch language of its value tree: to do this we simply replace every terminal of arity $n$ and type $A_1 \to \dots \to A_n \to A$ with $n$ distinct non terminals $f_i$ of arity 1 and type $A_i \to A$ and a non-terminal $\tilde F_i$ (of type $A_1 \to \dots \to A_n \to A$) with the (non-deterministic) set of rewriting rules $\tilde F_i x_1 \dots x_n \to x_i$ for $i=1 \dots n$. It is well known that the branch languages of an order 1 PHORS coincide with context free languages, while the branch languages of an order 2 PHORS coincide with the \textit{indexed languages} defined by Aho (cite) (check this, Ong says for word generating HORS  of order 2 safety is not a restriction!). 
\begin{example}
	Consider the deterministic, order 2 HORS $\gphors \bydef \phors$ defined as follows: its non terminals  are $S:\1$, $L: (\1 \to \1) \to \1 \to \1$, its terminals are $e: \1$ or arity 0, $l:\1 \to \1$ of arity 1 and $h:\1 \to \1 \to \1 $ of arity 2. Its rewriting rules are:
	\begin{align*}
		&S = L r e\\
		& L f k = h k (L f (L f k))   
	\end{align*}
	The first reduction steps will be $S \to L r e \to h e (L l (L l e))$ Now we can for example unfold the external $F$ and obtain $ h e (h (L l e) (L l (L l (L l e))))$.
\end{example}
PHORS are a probabilistic extension of HORS: they can be obtained by adding to the syntax of HORS a set new constant symbols $\oplus_p, p \in \mathbb{Q}$, of type $\1 \to \1 \to \1$, $t_1 \oplus_p t_2$ representing a probabilistic choice that chooses with probability $p$ the first argument and with probability $1-p$ the others. Following this intuition, we allow recursive definition of non terminals to be of the form $L x_1 \dots x_n \to t_L \to t_R$: this will induce the two (one step) rewriting rule $L t_1 \dots t_n \redbigp{L,p} t_L[x_1/t_1, \dots x_n/t_n]$  and  $L t_1 \dots t_n \redbigp{R,p} t_R[x_1/t_1, \dots x_n/t_n]$. We will consider from now only PHORS which are deterministic (i.e they have one reduction rule for each non-terminal). Here, we annotated the rewriting to keep track of the probability and the direction of this choice. If there exists a succession of rewriting steps $s \redbigp{\sigma_1 ,p_1} s_1 \dots  \redbigp{\sigma_k ,p_k} s_k$, we also write $s \redbigp{\sigma, p}^* s_k$ where $\sigma = \sigma_1 \dots \sigma_n$ and $p = p_1 \times \dots \times p_n$. Then we can define the probability of termination of a PHORS $\gphors = \phors$ :
$$\Pterm{\gphors}= \sum_{ n \: \text{normal form}}\sum_{S \redbigp{\sigma, p}n} p$$
end the expected number of steps to termination:
$$\ExpTime{\gphors}=  \sum_{ n \: \text{normal form}}\sum_{S \redbigp{\sigma, p}n} \len(\sigma) p$$
We can now define the two problems that will be central in this paper:
\begin{definition}
	\begin{itemize} Given a PHORS $\gphors$,
		\item AST is the problem to decide whether $\Pterm{\gphors}=1$
		\item PAST is the problem to decide  whether $\Pterm{\gphors} < + \infty$
	\end{itemize}
\end{definition}
It is known that PAST implies AST. On the other side, in (cite Ugo, Charles, Kobayashi), it can be proved that AST is undecidable for PHORS of order at least 1, while a decision procedure exists for PHORS of order 1. In (cite Ong paper on linear PHORS), it is shown that, if we restricting to applicative terms typable in an affine type system, AST and PAST are decidable for the class of \textit{affine PHORS} thus obtained. The proof builds upon the corresponndence, devised by Clairambault and Murawski in (cite), between affine PHORS and restricted stack automata. As a consequence of the theorems of section V, we will see that this can be proved in a completely different way, without resorting to automata, but rather relying on linear logic and its relational model.
\begin{remark}
	To each PHORS we can associate an HORS whose value tree represents all the probabilistic choices that we are faced with during the reduction: to this aim, it is enough to treat every $\oplus_p$ as a terminal symbol of arity 2. Based on this translation of PHORS to HORS and the aforementioned , we can see that the  branching structure of the aforementioned order 2 PHORS:
	\begin{align*}
		Hyx&=( H(A\circ y)x \oplus_{a}
		H(B\circ y)x )\oplus_{a}y(yx)\\
		Ax&= x\oplus_{b} \Omega\\
		Bx&=x\oplus_{c} \Omega\\
		S&=HIe
	\end{align*}
	cannot be simulated by any order 1 PHORS.
\end{remark}
\begin{remark}
 The recursive formalism of HORS can be expressed in the $\lambda Y$ calculus (i.e the STLC to which for each type $T$ a fixpoint combinator $Y_G: (T \to T) \to T$) is added). More precisely, there is an equivalence between $HORS$ and $\lambda Y$ terms of ground type. 
 \end{remark}