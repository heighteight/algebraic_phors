% !TEX root = main.tex
In this section we recall Higher Order Recursion Schemes (HORS), their probabilistic counterpart, Probabilistic  Higher Order Recursion Schemes (PHORS), as well as their correspondence with the (probabilistic) $\LY$-calculus. 

\subsection{HORS, a.k.a.~the $\LY$-calculus}
HORS, widely used in higher order model checking, can be seen as grammars that generate infinite ranked trees (or equivalently, infinite typed lambda terms).
In the theory of HORS, the simple types are generated by the grammar $T= \1 \mid T \to T$. We can also define the order of a type $ord(\1) =0$ and $ord(T \to S)= \max(ord(T)+1, ord(S))$.
A (deterministic) HORS $\gphors$ can be defined as a 4-uple $\phors$ where $\mathcal{N}$ is a set of typed non-terminals, $\mathcal{T}$ is a set of typed terminals, $S$ is a distinguished non-terminal called the starting symbol of $\gphors$ and $\mathcal{R}$ is a function associating each non-terminal $L$ with a rewriting rule of the form:
$L x_1 \dots x_n = t$, where $FV(t) \subseteq \{x_1, \dots x_n\} \cup \mathcal{T}$. These rules are to be understood as a (mutually) recursive definition of the non-terminals that can be progressively unfolded: to $\gphors$ we will associate the rewriting system induced by the rule $L t_1 \dots t_n \to t[x_1/t_1, \dots x_n/t_n]$. The rewriting, starting from $S$, will generate at each step finite (simply typed) terms containing the terminals $\mathcal{T}$; the "limit" of this set of terms will be the $\textit{value tree}$ defined by the $\mathcal{G}$ (for formal definitions, see \cite{DBLP:conf/lics/Ong15}, \cite{DBLP:books/ems/21/CarayolS21}). The nodes of this tree will be labelled by non terminals and its branching factor at each node will be equal to the arity of the non terminal labelling that node.  


The \emph{branch language} $\mathcal L_{\gphors}\subseteq \mathcal T^*$ of an HORS $\gphors$ is the branch language of its value tree: its words are the sequences of terminals encountered in some finite branch of the tree.
 It is well known that the branch languages of order-1 HORS coincide with the context-free languages, while the branch languages of order-2 HORS coincide with the \textit{indexed languages} defined by Aho \cite{DBLP:conf/focs/Aho67}. 


%If there is \textit{exactly} one equation for each non-terminal, the HORS is said deterministic; otherwise, it is non deterministic.Given an HORS, its order is defined as the maximal order of its non terminals.

%
%Ranked trees can be equivalently defined as set of words over an alphabet, called the \emph{branch language} of the tree (cite Courcelle, 1981 and survey by Ong). HORS can also deal with this different approach. To see this, recall that a word can be seen as a tree with branching factor at most one; hence an HORS only involving terminals of arity 1 is called a word-generating HORS. Given an HORS, we can always build another HORS of the same order that generate the branch language of its value tree: to do this we simply replace every terminal of arity $n$ and type $A_1 \to \dots \to A_n \to A$ with $n$ distinct non terminals $f_i$ of arity 1 and type $A_i \to A$ and a non-terminal $\tilde F_i$ (of type $A_1 \to \dots \to A_n \to A$) with the (non-deterministic) set of rewriting rules $\tilde F_i x_1 \dots x_n \to x_i$ for $i=1 \dots n$.
% It is well known that the branch languages of an order 1 PHORS coincide with context free languages, while the branch languages of an order 2 PHORS coincide with the \textit{indexed languages} defined by Aho (cite) (check this, Ong says for word generating HORS  of order 2 safety is not a restriction!). 
\begin{example}
	Consider the order-2 HORS $\gphors \bydef \phors$ defined as follows: its non terminals  are $S:\1$, $L: (\1 \to \1) \to \1 \to \1$, its terminals are $e: \1$ or arity 0, $l:\1 \to \1$ of arity 1 and $h:\1 \to \1 \to \1 $ of arity 2. Its rewriting rules are:
	\begin{align*}
		&S = L r e\\
		& L f k = h k (L f (L f k))   
	\end{align*}
	The first reduction steps are $S \to L r e \to h e (L l (L l e))$. Now we can for example unfold the leftmost $L$ and obtain $ h e (h (L l e) (L l (L l (L l e))))$.
\end{example}


The language of HORS is equivalent to the $\LY$-calculus, that is, the simply-typed $\lambda$-calculus enriched with cartesian products and a fixpoint $Y:(T\to T)\to T$: 
in $\gphors=(\nonterm, \C T, \C R, S)$ the function $\C R$ can be equivalently defined as a
function associating each non-terminal $L\in \nonterm$ with a simply typed term 
$\nonterm\vdash \lambda x_1.\dots. x_n. t_L:\nonterm(L)$, such that $t_L$ contains no $\lambda$-abstraction and 
$\nonterm, x_1,\dots, x_n\vdash t_L:\1$. 
To $\gphors$ can we then associate the $\LY$-term
$Yt_{\gphors}:\nonterm$, where 
$t_{\gphors}:= \lambda \langle L_1,\dots, L_n\rangle. \langle  t_{L_1} \dots  t_{L_n}\rangle: \nonterm\to \nonterm$.



%
%
%Given a HORS $\gphors$:
% \begin{equation*}
%\label{phors010}
% 	\left\{
% 	\begin{aligned}
% 		&L_1 x_{1,1} \dots  x_{1,k_1} = t_1\\
% 		&\dots \\
% 		&L_1 x_{n,1} \dots  x_{n,k_n} = t_n\\
% 	\end{aligned}
% 	\right.
%	\end{equation*}
%define the term 
%\[
%M_{\gphors}:= Y \ \lambda \langle L_1,\dots, L_n\rangle. \langle \bar t_1 \dots \bar t_n \rangle,
%\]
%where $\bar t_i \bydef \lambda x_{i,1} \dots \lambda x_{x, n_i}. t_i$. Letting  
%$\Gamma_{\mathcal T}$ be the set of assignments $f:T_f$ associating each terminal $f\in \mathcal T$ with its type, we can then associate each non-terminal $L_i:T$ with a term 
%$M_{L_i}:=\pi_iM_{\gphors}$ so that $
%\Gamma_{\mathcal T}\vdash_{\LY} M_{L_i}:T$.
%




\subsection{PHORS, a.k.a.~the Probabilistic $\LY$-calculus}
PHORS are a probabilistic extension of HORS: they can be obtained by adding to the syntax of HORS a set of new constant symbols $\oplus_p, p \in \mathbb{Q}\cap[0,1]$, of type $\1 \to \1 \to \1$, $t_1 \oplus_p t_2$ representing a probabilistic choice that chooses with probability $p$ the first argument and with probability $1-p$ the others. Following this intuition, we allow recursive definitions of non terminals to be of the form 
\[L x_1 \dots x_n = t_L \oplus_p t_R,\]
with the two (one step) probabilistic rewriting rules
\begin{align*} 
L t_1 \dots t_n & \redbigp{\mathsf l,p} t_L[x_1/t_1, \dots x_n/t_n],\\
L t_1 \dots t_n &\redbigp{\mathsf r,1-p} t_R[x_1/t_1, \dots x_n/t_n].
\end{align*}
% We will consider from now only PHORS which are deterministic (i.e they have one reduction rule for each non-terminal). 
 Here, we annotated the rewriting to keep track of the probability and the direction of this choice. For a reduction $R: s \redbigp{\sigma_1 ,p_1} s_1 \dots  \redbigp{\sigma_k ,p_k} s_k$, we also write $R:s \redbigp{\sigma,p} s_k$, where
 $\sigma = \sigma_1 \dots \sigma_n$ and $p = p_1\dots p_n$.
% , and we call 
% $a(R)=\sigma$ and
% $w(R)=p$, respectively, the \emph{address and weight of $R$}. 
 
%Following (Dal Lago Grellois), we will restrict attention to PHORS $\gphors$ with a unique terminal symbol $\mathcal T=\{e:\1\}$.
 
 Given a PHORS $\gphors=(\nonterm, \C R,S)$, we can define its probability of termination
 and expected number of steps to termination as
 \begin{align*}
 \Pterm{\gphors}&:= \sum_{ n \: \text{normal form}}\sum_{R:S \redbigp{\sigma, p} n} p \\
 \ExpTime{\gphors}&:=  \sum_{ n \: \text{normal form}}\sum_{R:S \redbigp{\sigma, p} n} |\sigma |p
 \end{align*}
We can now define the two central problems of this paper:
\begin{definition}
	Given a PHORS $\gphors$, the AST problem asks to decide whether $\Pterm{\gphors}=1$, while the PAST problem asks to decide  whether $\Pterm{\gphors} < + \infty$
\end{definition}

Following \cite{DBLP:journals/lmcs/KobayashiLG20}, we focus on PHORS with a unique terminal symbol $e:\1$. A PHORS will thus be given as a triple $\gphors=(\nonterm, \C R, S)$. 


\begin{example}\label{ex:phors0}
Consider the order-1 PHORS defined by
\begin{align*}
Fx&= F(Fx)\oplus_{\frac{1}{2}} x,\\
S&= Fe.
\end{align*}
As any choice either adds one $F$ or deletes one, and termination comes when $e$ is reached, it simulates a simple random walk starting from $+1$, adding $\pm 1$ at each step and terminating at $0$. We will see in the next sections that the aforementioned PHORS is AST but not PAST. 
\end{example}

It is known that PAST implies AST. On the other hand, in \cite{DBLP:journals/lmcs/KobayashiLG20}, it is proved that AST is undecidable for PHORS of order at least 2, while a decision procedure exists for PHORS of order 1. In \cite{DBLP:conf/lics/LiMO22}, it is shown that, if we restrict to terms typable via affine types, AST and PAST are decidable. The proof builds upon the correspondence, devised in \cite{DBLP:conf/mfcs/ClairambaultM19}, between affine PHORS and restricted stack automata. As a consequence of the theorems of Section 6, we will see that this can be proved in a completely different way, without resorting to automata, but rather relying on the relational model of linear logic.



\begin{remark}
	To each PHORS we can associate an HORS whose value tree represents the probabilistic choices made during reduction: to this aim, it is enough to treat every $\oplus_p$ as a terminal symbol of arity 2. This way, we can see that the branching structure of the order-2 PHORS \eqref{eq:phors1} from Section 2, yielding a non-context free branch language, 
%	:
%	\begin{align*}
%		Hyx&=( H(A\circ y)x \oplus_{a}
%		H(B\circ y)x )\oplus_{a}y(yx)\\
%		Ax&= x\oplus_{b} \Omega\\
%		Bx&=x\oplus_{c} \Omega\\
%		S&=HIe
%	\end{align*}
	cannot be simulated by any order-1 PHORS.
\end{remark}


The language of PHORS is equivalent to the $\PLY$-calculus, that is, the extension of $\LY$ with (ground) choice operators $M \oplus_p N$, with 
reduction rules
$M\oplus_p N  \redbigp{\mathsf l,p} M$,
$M\oplus_p N \redbigp{\mathsf r,1-p} N$, and typing rule
\[
\infer{\Gamma\vdash M\oplus_p N:\1}{\Gamma\vdash M:\1 & \Gamma\vdash N:\1}.
\]
The \emph{call-by-name reduction $\redbigp{}$} of the $\PLY$-calculus is the closure of the reductions above as well as 
 $\beta$-reduction $(\lambda x.M)N\redbigp{\epsilon,1} M[N/x]$ and $Y$-reduction $YM\redbigp{\epsilon,1}M(YM)$ under the congruence
 $M\redbigp{\sigma, p} N \ \Rightarrow \ MP \redbigp{\sigma, p} NP$.
%  The address and weight of a reduction can be defined as for PHORS. 
  
 
The translation of a PHORS $\gphors$ into a term $M_{\gphors}$ of the $\PLY$-calculus works as in the case of HORS. In particular, reductions sequences $R:S\redbigp{\sigma, p}n$ to normal form are in one-to-one correspondence with probabilistic call-by-name reductions $R:M_S\redbigp{\sigma, p}n$ to normal form in $\PLY$.
For example, the PHORS from Example \ref{ex:phors0} is encoded in $\PLY$ by $Yt_{\gphors}$, with $t_{\gphors}=Y \lambda\langle F,S\rangle. t':(\1\to \1)\times \1$ and  
$t'=
\langle \lambda  x.F(Fx)\oplus_{\frac{1}{2}} x, Fe\rangle$. 




%
%
% The recursive formalism of (P)HORS can be expressed in the $\LY$ calculus (i.e the STLC to which for each type $T$ a fixpoint combinator $Y_G: (T \to T) \to T$) is added). In particular, given a PHORS:
% \begin{equation*}
% 	\label{phors010}
% 	\left\{
% 	\begin{aligned}
% 		&L_1 f_{1,1} \dots  f_{1,k_1} = t_1\\
% 		&\dots \\
% 		&L_1 f_{n,1} \dots  f_{n,k_n} = t_n\\
% 	\end{aligned}
% 	\right.
% \end{equation*}
% we associate to it the $\LY$ term $\fix  \lambda.\langle L_1 \dots  L_n \rangle . \langle \bar t_1 \dots \bar t_n \rangle$, where $\bar t_i \bydef \lambda f_{i,1} \dots \lambda f_{i, n_i}. t$.