% !TEX root = main.tex
In this section we recall Higher Order Recursion Schemes (HORS), their probabilistic counterpart, Probabilistic  Higher Order Recursion Schemes (PHORS), as well as their correspondence with the $\lambda Y$-calculus. 

\subsection{HORS, a.k.a.~the $\lambda Y$-calculus}
HORS, widely used in higher order model checking, can be seen as grammars that generate infinite ranked trees (or equivalently, infinite typed lambda terms).
In the theory of HORS, the simple types are generated by the grammar $T= \1 \mid T \to T$. We can also define the order of a type $ord(\1) =0$ and $ord(T \to S)= \max(ord(T)+1, ord(S))$.
An HORS $\gphors$ can then be defined as a 4-uple $\phors$ where $\mathcal{N}$ is a set of typed non-terminals, $\mathcal{T}$ is a set of typed terminals, $S$ is a distinguished non-terminal called the starting symbol of $\gphors$ and $\mathcal{R}$ is a set of rewriting rules, at least one for each non terminal, of the form:
$L x_1 \dots x_n = t$, where $FV(t) \subseteq \{x_1, \dots x_n\} \cup \mathcal{T}$. These rules are to be understood as recursive definition of the non-terminals that can be progressively unfolded: to $\gphors$ we will associate the rewriting system induced by the rules $L t_1 \dots t_n \to t[x_1/t_1, \dots x_n/t_n]$. The rewriting - beginning from $S$ - will generate at each step finite (simply typed) terms containing the terminals $\mathcal{T}$; the "limit" of this set of terms will be the $\textit{value tree}$ defined by the $\mathcal{G}$ (for formal definitions, see Carayol or the overview by Ong). The nodes of this tree will be labelled by non terminals and its branching factor at each node will be equal to the arity of the non terminal labelling that node.  


The \emph{branch language} $\mathcal L_{\gphors}\subseteq \mathcal T^*$ of an HORS $\gphors$ is the branch language of its value tree: its words are the sequences of terminals encountered in some branch of the tree.
 It is well known that the branch languages of order-1 PHORS coincide with context free languages, while the branch languages of order-2 PHORS coincide with the \textit{indexed languages} defined by Aho (cite) (check this, Ong says for word generating HORS  of order 2 safety is not a restriction!). 


%If there is \textit{exactly} one equation for each non-terminal, the HORS is said deterministic; otherwise, it is non deterministic.Given an HORS, its order is defined as the maximal order of its non terminals.

%
%Ranked trees can be equivalently defined as set of words over an alphabet, called the \emph{branch language} of the tree (cite Courcelle, 1981 and survey by Ong). HORS can also deal with this different approach. To see this, recall that a word can be seen as a tree with branching factor at most one; hence an HORS only involving terminals of arity 1 is called a word-generating HORS. Given an HORS, we can always build another HORS of the same order that generate the branch language of its value tree: to do this we simply replace every terminal of arity $n$ and type $A_1 \to \dots \to A_n \to A$ with $n$ distinct non terminals $f_i$ of arity 1 and type $A_i \to A$ and a non-terminal $\tilde F_i$ (of type $A_1 \to \dots \to A_n \to A$) with the (non-deterministic) set of rewriting rules $\tilde F_i x_1 \dots x_n \to x_i$ for $i=1 \dots n$.
% It is well known that the branch languages of an order 1 PHORS coincide with context free languages, while the branch languages of an order 2 PHORS coincide with the \textit{indexed languages} defined by Aho (cite) (check this, Ong says for word generating HORS  of order 2 safety is not a restriction!). 
\begin{example}
	Consider the order-2 HORS $\gphors \bydef \phors$ defined as follows: its non terminals  are $S:\1$, $L: (\1 \to \1) \to \1 \to \1$, its terminals are $e: \1$ or arity 0, $l:\1 \to \1$ of arity 1 and $h:\1 \to \1 \to \1 $ of arity 2. Its rewriting rules are:
	\begin{align*}
		&S = L r e\\
		& L f k = h k (L f (L f k))   
	\end{align*}
	The first reduction steps will be $S \to L r e \to h e (L l (L l e))$ Now we can for example unfold the external $F$ and obtain $ h e (h (L l e) (L l (L l (L l e))))$.
\end{example}


The language of HORS is equivalent to the $\lambda Y$-calculus, that is, the simply-typed $\lambda$-calculus enriched with cartesian products and a fixpoint $Y:(T\to T)\to T$. 
Given a HORS $\gphors$:
 \begin{equation*}
\label{phors010}
 	\left\{
 	\begin{aligned}
 		&L_1 x_{1,1} \dots  x_{1,k_1} = t_1\\
 		&\dots \\
 		&L_1 x_{n,1} \dots  x_{n,k_n} = t_n\\
 	\end{aligned}
 	\right.
	\end{equation*}
define the term 
\[
M_{\gphors}:= Y \ \lambda \langle L_1,\dots, L_n\rangle. \langle \bar t_1 \dots \bar t_n \rangle,
\]
where $\bar t_i \bydef \lambda x_{i,1} \dots \lambda x_{x, n_i}. t_i$. Letting  
$\Gamma_{\mathcal T}$ be the set of assignments $f:T_f$ associating each terminal $f\in \mathcal T$ with its type, we can then associate each non-terminal $L_i:T$ with a term 
$M_{L_i}:=\pi_iM_{\gphors}$ so that $
\Gamma_{\mathcal T}\vdash_{\lambda Y} M_{L_i}:T$.





\subsection{PHORS, a.k.a.~the $\lambda_{\oplus} Y$-calculus}
PHORS are a probabilistic extension of HORS: they can be obtained by adding to the syntax of HORS a set new constant symbols $\oplus_p, p \in \mathbb{Q}$, of type $\1 \to \1 \to \1$, $t_1 \oplus_p t_2$ representing a probabilistic choice that chooses with probability $p$ the first argument and with probability $1-p$ the others. Following this intuition, we allow recursive definition of non terminals to be of the form 
\[L x_1 \dots x_n \to t_L \oplus_p t_R,\]
with the two (one step) rewriting rules
\begin{align*} 
L t_1 \dots t_n & \redbigp{\mathsf l,p} t_L[x_1/t_1, \dots x_n/t_n],\\
L t_1 \dots t_n &\redbigp{\mathsf r,p} t_R[x_1/t_1, \dots x_n/t_n].
\end{align*}
% We will consider from now only PHORS which are deterministic (i.e they have one reduction rule for each non-terminal). 
 Here, we annotated the rewriting to keep track of the probability and the direction of this choice. For a reduction $R: s \redbigp{\sigma_1 ,p_1} s_1 \dots  \redbigp{\sigma_k ,p_k} s_k$, we also write $R:s \redbigp{\sigma,p} s_k$, where
 $\sigma = \sigma_1 \dots \sigma_n$ and $p = p_1 \times \dots \times p_n$, and we call 
 $a(R)=\sigma$ and
 $w(R)=p$, respectively, the \emph{address and weight of $R$}. 
 
%Following (Dal Lago Grellois), we will restrict attention to PHORS $\gphors$ with a unique terminal symbol $\mathcal T=\{e:\1\}$.
 
 Then we can define the probability of termination of a PHORS $\gphors = \phors$ :
$$\Pterm{\gphors}= \sum_{ n \: \text{normal form}}\sum_{R:S \redbigp{\sigma, p} n} p$$
end the expected number of steps to termination:
$$\ExpTime{\gphors}=  \sum_{ n \: \text{normal form}}\sum_{R:S \redbigp{\sigma, p} n} |\sigma |p $$
We can now define the two problems that will be central in this paper:
\begin{definition}
	\begin{varitemize} Given a PHORS $\gphors$,
		\item AST is the problem to decide whether $\Pterm{\gphors}=1$
		\item PAST is the problem to decide  whether $\Pterm{\gphors} < + \infty$
	\end{varitemize}
\end{definition}

\begin{example}\label{ex:phors0}
Consider the order-1 PHORS defined by
\begin{align*}
Fx&= F(Fx)\oplus_{\frac{1}{2}} x,\\
S&= Fe.
\end{align*}
As any choice either adds one $F$ or deletes one, and termination comes when $e$ is reached, it simulates a simple random walk starting from $+1$, adding $\pm 1$ at each step and terminating at $0$. We will see in the next sections that it is AST but not PAST. 
\end{example}

It is known that PAST implies AST. On the other side, in (cite Ugo, Charles, Kobayashi), it can be proved that AST is undecidable for PHORS of order at least 1, while a decision procedure exists for PHORS of order 1. In (cite Ong paper on linear PHORS), it is shown that, if we restricting to applicative terms typable in an affine type system, AST and PAST are decidable for the class of \textit{affine PHORS} thus obtained. The proof builds upon the corresponndence, devised by Clairambault and Murawski in (cite), between affine PHORS and restricted stack automata. As a consequence of the theorems of section V, we will see that this can be proved in a completely different way, without resorting to automata, but rather relying on linear logic and its relational model.



\begin{remark}
	To each PHORS we can associate an HORS whose value tree represents all the probabilistic choices that we are faced with during the reduction: to this aim, it is enough to treat every $\oplus_p$ as a terminal symbol of arity 2. Based on this translation of PHORS to HORS, we can see that the branching structure of the order-2 PHORS \eqref{eq:phors1}, yielding a non-context free branch language, 
%	:
%	\begin{align*}
%		Hyx&=( H(A\circ y)x \oplus_{a}
%		H(B\circ y)x )\oplus_{a}y(yx)\\
%		Ax&= x\oplus_{b} \Omega\\
%		Bx&=x\oplus_{c} \Omega\\
%		S&=HIe
%	\end{align*}
	cannot be simulated by any order-1 PHORS.
\end{remark}


The language of PHORS is equivalent to the $\lambda_{\oplus} Y$-calculus, that is, the extension of $\lambda Y$ with (ground) choice operators $M \oplus_p N$, with 
reduction rules
\begin{align*} 
M\oplus_p N & \redbigp{L,p} M &
M\oplus_p N &\redbigp{R,p} N,
\end{align*}
and typing rule
\[
\infer{\Gamma\vdash M\oplus_p N:\1}{\Gamma\vdash M:\1 & \Gamma\vdash N:\1}.
\]
The \emph{call-by-value reduction $\redbigp{}$} of the $\lambda_{\oplus} Y$-calculus is the closure of the reductions above as well as 
 $\beta$-reduction $(\lambda x.M)N\redbigp{\epsilon,1} M[N/x]$ and $Y$-reduction $YM\redbigp{\epsilon,1}M(YM)$ under the rule
 $M\redbigp{\sigma, p} N \ \Rightarrow \ MP \redbigp{\sigma, p} NP$. The address and weight of a reduction can be defined as for the PHORS. 
  
 
The translation of a PHORS $\gphors$ into a term $M_{\gphors}$ of the $\lambda_{\oplus} Y$-calculus works exactly as in the case of HORS. In particular, the reductions $R:S\redbigp{\sigma, p}n$ to normal form are in one-to-one correspondences with probabilistic call-by-value reductions $R:M_S\redbigp{\sigma, p}n$ to normal form in $\lambda_{\oplus} Y$, with same addresses and weights.

\begin{example}\label{ex:phors1}

The PHORS $\gphors$ from Example \ref{ex:phors0} is encoded in $\Lambda Y$ by $M_{\gphors}=Y \lambda\langle F,S\rangle. M':(\1\to \1)\times \1$, where 
$M'=
\langle \lambda  x.F(Fx)\oplus_{\frac{1}{2}} x, Fe\rangle$. 


\end{example}


%
%
% The recursive formalism of (P)HORS can be expressed in the $\lambda Y$ calculus (i.e the STLC to which for each type $T$ a fixpoint combinator $Y_G: (T \to T) \to T$) is added). In particular, given a PHORS:
% \begin{equation*}
% 	\label{phors010}
% 	\left\{
% 	\begin{aligned}
% 		&L_1 f_{1,1} \dots  f_{1,k_1} = t_1\\
% 		&\dots \\
% 		&L_1 f_{n,1} \dots  f_{n,k_n} = t_n\\
% 	\end{aligned}
% 	\right.
% \end{equation*}
% we associate to it the $\lambda Y$ term $\fix  \lambda.\langle L_1 \dots  L_n \rangle . \langle \bar t_1 \dots \bar t_n \rangle$, where $\bar t_i \bydef \lambda f_{i,1} \dots \lambda f_{i, n_i}. t$.